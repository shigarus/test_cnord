Реализовать серверное приложение на tornado. Приложение должно слушать на двух tcp-портах (8888 и 8889). По
первому порту оно должно принимать подключения и сообщения от подключенных клиентов ("источников").

Структура сообщения от источника:
1 байт - header (всегда 0x01)
2 байта - номер сообщения в пределах данного подключения (беззнаковое целое)
8 байт - идентификатор источника (ascii-строка)
1 байт - статус источника, (беззнаковое целое), возможные занчения: 0x01 -- IDLE, 0x02 -- ACTIVE, 0x03 --RECHARGE
1 байт - numfields, количество полей с данными (беззнаковое целое)

Затем, в соответствии со значением поля numfields, идёт несколько пар полей следующего вида:
8 байт - имя поля (ascii-строка)
4 байта - значение поля (беззнаковое целое)
1 байт - побайтовый XOR от сообщения

Сервер приложения в ответ присылает сообщения следующего вида:
1 байт - header. Если сообщение было обработано успешно - 0x11, в противном случае - 0x12
2 байта - номер сообщения или 0x00 0x00, если разобрать сообщение не удалось
1 байт - побайтовый XOR от сообщения (своего).

Всем подключенным клиентам ("слушателям") на порту 8889 приложение должно отправлять на каждое принятое от
источника сообщение сообщения в текстовом формате следующего вида:
"[<идентификатор источника>] <Имяполя> | <Значение>\r\n"
по одной строке на каждую пару "имя - значение" в сообщении от источника.

При подключении нового слушателя на порт 8889, приложение должно отправить ему список всех подключенных на
данный момент источников в формате:
[<идентификатор источника>] <номер последнего сообщения> | <статус (строка "IDLE", "ACTIVE" или
"RECHARGE")> | <время, прошедшее с момента получения последнего сообщения в целых миллисекундах>\r\n
(по одной строчке на каждый источник)


Ключевые утверждения в тз:
1) Приложение должно служить транспортом информации из источников к слушателям.
2) Каждое сообщение источника представляет собой n под-сообщений каждому слушателю.
3) Сообщение источника может быть невалидным, о чем его нужно уведомлять.
4) Источник имеет состояние в виде некой константы и времени последнего сообщения.
5) Каждый слушатель на подключение получает состояние всех источников.

Допущения на основе утверждений:
1) Колчество под-сообщений может быть n>=0.
2) Слушатель желает знать обо всех подключенных источниках до получения сообщений от них - тогда
   его нужно информировать и о тех, что были подключены в процессе его работы с приложением.
3) Т.к. слушателя интересует статус источника и время последнего сообщения - считаем источника подключившимся
   только после первого корректного сообщения, т.к. по некорректному не понять статус.
4) Посылать слушателю сообщение от источника можно только тогда, когда он уже уведомлен о существовании
   этого источника.
5) Ничего не сказано о дерегистрации источников и возможности вмешаться в протокол связи с ними - храним
   источники вечно.
